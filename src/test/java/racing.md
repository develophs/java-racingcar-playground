기능 요구 사항 정의서

초간단 자동차 경주 게임을 구현한다.
- [x] 주어진 횟수 동안 n대의 자동차는 전진 또는 멈출 수 있다.
- [x] 사용자는 몇 대의 자동차로 몇 번의 이동을 할 것인지를 입력할 수 있어야 한다.
  - [x] 입력을 받는 객체 Reader#read() -> String, int
  - [x] 입력한 자동차 수 만큼 자동차를 생성한다. -> 자동차 생성 객체 CarFacotry.construct(String carName)
  - [x] 입력한 횟수 만큼 경기를 진행한다. -> 경기 진행 객체 -> GameRound(int round)
  - [x] 위 세개의 객체들을 서로 협력을 통해 입력, 자동차생성, 경기를 진행한다.
- [x] 전진하는 조건은 0에서 9 사이에서 random 값을 구한 후 random 값이 4이상일 경우이다.
  - [x] 난수 발생 객체 NumberGenerator#generate()
  - [x] 난수가 4이상인지 판단하고(boolean), 4이상인 경우 자동차를 전진시킨다.
  - [x] 값을 자동차에게 전달하고 자동차에서 4이상이면 전진 v1.Car#proceed(int random)
- [x] 자동차의 상태를 화면에 출력한다. 어느 시점에 출력할 것인지에 대한 제약은 없다.
  - 자동차가 자신의 step을 출력하도록 변경했다. 자기 자신의 데이터를 본인이 출력하도록.
- [x] 각 자동차에 이름을 부여할 수 있다.
- [x] 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다.
- [x] 자동차 이름은 쉼표(,)를 기준으로 구분한다.
  - a,b,c 분리하여 배열 StringSplitter(String)#split(String delimiter)
  - 배열로 구성된 자동차 이름으로 자동차 생성
- [x] 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다.
  - [x] 상태값이 가장 큰 자동차를 우승자로 한다. Cars에서 직접 Car들의 step을 계산하여 최대값을 가진 자동차들을 우승자로 선정한다.
  - [x] 공동 우승이 가능하다 > 자동차들의 상태중 MAX값을 구하고, MAX값인 자동차를 우승자로 한다.

v2 :
0. 모든 원시값과 문자열을 포장하자.
1. 불변 객체, getter 최대한 지양
2. 자동차의 값끼리 계속 비교하는건 절차지향적 생각이다. >> 객체 자체끼리 비교하자
3. MVC 패턴으로 생각해서 바꿔보자
4. 자동차 이름이 5자리를 초과하면 게임이 죽는다. >> 다시 입력하게 끔해서 게임이 죽지 않도록 하자